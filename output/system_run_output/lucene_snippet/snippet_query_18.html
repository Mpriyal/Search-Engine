<h2>Query - 18 languages and compilers for parallel processors especially highly horizontal microcoded machines code compaction</h2><h3>CACM-1811.txt</h3><br>=========================<br>a case study in programming for <B>parallel</B>-<B>processors</B> an affirmative partial answer is provided to the question of whether it is possible to program <B>parallel</B>-processor computing<br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> problems <B>parallel</B><br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> of the <B>processors</B> can<br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> problem the <B>processors</B><br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> <B>processors</B> communication<br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> <B>processors</B><br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> <B>processors</B> a program<br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> was written for a <B>parallel</B><br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> <B>processors</B> are applied<br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> of <B>processors</B> stability<br>****************************<br><br><br><h3>CACM-1811.txt</h3><br>=========================<br> <B>parallel</B>-processor parallelism <B>parallel</B><br>****************************<br><br><br><h3>CACM-1988.txt</h3><br>=========================<br>a formalism for translator interactions a formalism is presented for describing the actions of <B>processors</B> for programming <B>languages</B>-<B>compilers</B> interpreters assemblers-and their interactions in complex systems such as compiler-<B>compilers</B> or extendible <B>languages</B> the formalism here might be used to define and answer such a question as can one do bootstrapping using a meta-compiler<br>****************************<br><br><br><h3>CACM-1988.txt</h3><br>=========================<br> <B>processors</B> cacm<br>****************************<br><br><br><h3>CACM-2714.txt</h3><br>=========================<br>merging with <B>parallel</B> <B>processors</B> consider two linearly ordered sets a b am bn mn and p pm <B>parallel</B> <B>processors</B> working synchronously the paper presents an algorithm for merging a and b with the p <B>parallel</B> <B>processors</B> which requires at most 2log2 2m13mp  mplog2 nm steps if n  2bm b an integer the algorithm requires<br>****************************<br><br><br><h3>CACM-2714.txt</h3><br>=========================<br> best <B>parallel</B><br>****************************<br><br><br><h3>CACM-2714.txt</h3><br>=========================<br> gavril f <B>parallel</B> processing <B>parallel</B> merging <B>parallel</B> binary<br>****************************<br><br><br><h3>CACM-2138.txt</h3><br>=========================<br>bliss a language for systems programming a language bliss is described this language is designed so as to be <B>especially</B> suitable for use in writing production software systems for a specific machine the pdp-10 <B>compilers</B> operating systems etc prime design goals of the design are the ability to produce <B>highly</B> efficient object <B>code</B> to allow access to all relevant hardware<br>****************************<br><br><br><h3>CACM-2138.txt</h3><br>=========================<br> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-3110.txt</h3><br>=========================<br>assembling <B>code</B> for <B>machines</B> with span-dependent instructions many modern computers contain instructions whose lengths depend on the distance from a given instance of such an instruction to the operand of that instruction this paper considers the problem of minimizing the lengths of programs for such <B>machines</B> an efficient solution is presented for the case<br>****************************<br><br><br><h3>CACM-3110.txt</h3><br>=========================<br> addressing <B>code</B><br>****************************<br><br><br><h3>CACM-3110.txt</h3><br>=========================<br> <B>compilers</B> np-complete<br>****************************<br><br><br><h3>CACM-3156.txt</h3><br>=========================<br>computing connected components on <B>parallel</B> computers we present a <B>parallel</B> algorithm which uses n2 <B>processors</B> to find the connected components of an undirected graph with n vertices in time olog2n an olog2n time bound also can be achieved using only nnlog2n <B>processors</B> the algorithm can be used to find the transitive closure of a symmetric boolean matrix we<br>****************************<br><br><br><h3>CACM-3156.txt</h3><br>=========================<br> that the <B>processors</B> have access<br>****************************<br><br><br><h3>CACM-3156.txt</h3><br>=========================<br> graph theory <B>parallel</B><br>****************************<br><br><br><h3>CACM-1852.txt</h3><br>=========================<br>a base for a mobile programming system an algorithm for a macro processor which has been used as the base of an implementation by bootstrapping of <B>processors</B> for programming <B>languages</B> is described this algorithm can be easily implemented on contemporary computing <B>machines</B> experience with programming <B>languages</B> whose implementation is based on this algorithm indicates<br>****************************<br><br><br><h3>CACM-1852.txt</h3><br>=========================<br> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-2175.txt</h3><br>=========================<br>subexpression ordering in the execution of arithmetic expressions an arithmetic expression can often be broken down into its component subexpressions depending on the hardware environment in which the expression is to be executed these subexpressions can be evaluated in serials in <B>parallel</B> or in a combination<br>****************************<br><br><br><h3>CACM-2175.txt</h3><br>=========================<br> in <B>parallel</B> exceeds<br>****************************<br><br><br><h3>CACM-2175.txt</h3><br>=========================<br> <B>processors</B><br>****************************<br><br><br><h3>CACM-2175.txt</h3><br>=========================<br> <B>parallel</B> processing cache<br>****************************<br><br><br><h3>CACM-2175.txt</h3><br>=========================<br> trees <B>compilers</B> 4.12<br>****************************<br><br><br><h3>CACM-3075.txt</h3><br>=========================<br>fast <B>parallel</B> sorting algorithms a <B>parallel</B> bucket-sort algorithm is presented that requires time olog n and the use of n <B>processors</B> the algorithm makes use of a technique that requires more space than the product of <B>processors</B> and time a realistic model is used model is used in which no memory contention is permitted a procedure is also presented to sort n<br>****************************<br><br><br><h3>CACM-3075.txt</h3><br>=========================<br> <B>processors</B> for k<br>****************************<br><br><br><h3>CACM-3075.txt</h3><br>=========================<br> hirschberg d <B>parallel</B><br>****************************<br><br><br><h3>CACM-2112.txt</h3><br>=========================<br>translation equations input limited transduction expressions or translation equations are used to describe the syntax and left-context sensitive semantics for context-free <B>languages</B> a formal procedure is given for deriving from a set of translation equations the specifications for a pushdown translator the translator<br>****************************<br><br><br><h3>CACM-2112.txt</h3><br>=========================<br> automata turing <B>machines</B><br>****************************<br><br><br><h3>CACM-2112.txt</h3><br>=========================<br> <B>languages</B> translation<br>****************************<br><br><br><h3>CACM-2112.txt</h3><br>=========================<br>-<B>compilers</B> pushdown<br>****************************<br><br><br><h3>CACM-2112.txt</h3><br>=========================<br> directed <B>compilers</B><br>****************************<br><br><br><h3>CACM-0670.txt</h3><br>=========================<br>some legal implications of the use of computers in the banking business the introduction of computers in to the banking business has a wide variety of legal implications that merit careful attention at this very early stage the industry is <B>highly</B> regulated by government and hence is subject to many statutes and regulations it also is affected by important<br>****************************<br><br><br><h3>CACM-0670.txt</h3><br>=========================<br> are <B>especially</B> diverse<br>****************************<br><br><br><h3>CACM-0670.txt</h3><br>=========================<br> <B>processors</B> particularly<br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br>a case study of a new <B>code</B> generation technique for <B>compilers</B> recent developments in optimizing techniques have allowed a new design for <B>compilers</B> to emerge such a compiler translates the parsed source <B>code</B> into lower level <B>code</B><br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> level <B>code</B><br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> of tailoring this <B>code</B> to take<br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> <B>code</B><br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> to produce good <B>code</B><br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> <B>code</B> for most contexts<br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> statement the <B>code</B><br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> with the <B>code</B> produced<br>****************************<br><br><br><h3>CACM-2897.txt</h3><br>=========================<br> optimizing compiler <B>code</B><br>****************************<br><br><br><h3>CACM-2495.txt</h3><br>=========================<br>adapting optimal <B>code</B> generation for arithmetic expressions to the instruction sets available on present-day computers cacm june 1973 stockhausen p f arithmetic expressions <B>code</B> generation <B>compilers</B> object-<B>code</B> optimization register assignment trees 4.12 5.24 5.32 ca730605 jb january 23 1978 2:24 pm 2495 5 2495 2495 5 2495 2495 5 2495<br>****************************<br><br><br><h3>CACM-0950.txt</h3><br>=========================<br><B>parallel</B> methods for integrating ordinary differential equations this paper is dedicated to the proposition that in order to take full advantage for real-time computations of <B>highly</B> <B>parallel</B> computers as can be expected to be available in the near future much of numerical analysis will have to be recast in a more <B>parallel</B> form by this is meant that serial algorithms ought to be replaced<br>****************************<br><br><br><h3>CACM-2266.txt</h3><br>=========================<br>a <B>highly</B> <B>parallel</B> algorithm for approximating all zeros of a polynomial with only real zeros an algorithm is described based on newtons method which simultaneously approximates all zeros of a polynomial with only real zeros the algorithm which is conceptually suitable for <B>parallel</B> computation determines its own starting values so that convergence to the zeros is guaranteed<br>****************************<br><br><br><h3>CACM-2266.txt</h3><br>=========================<br> m l <B>parallel</B><br>****************************<br><br><br><h3>CACM-1795.txt</h3><br>=========================<br>optimal <B>code</B> for serial and <B>parallel</B> computation cacm december 1969 fateman r j <B>code</B> optimization sequencing of operations detection of common subexpressions 4.12 ca691217 jb february 15 1978 1:59 pm 1795 5 1795 1795 5 1795 1795 5 1795<br>****************************<br><br><br><h3>CACM-2921.txt</h3><br>=========================<br>regular right part grammars and their parsers this paper in troduces an alternative to context-free grammars called regular right part rrp grammars which resemble pascal syntax diagrams formally rrp grammars have production right parts which are nondeterministic finite state <B>machines</B> fsms and as a special case regular<br>****************************<br><br><br><h3>CACM-2921.txt</h3><br>=========================<br> <B>languages</B> more<br>****************************<br><br><br><h3>CACM-2921.txt</h3><br>=========================<br> <B>machines</B> automata<br>****************************<br><br><br><h3>CACM-2921.txt</h3><br>=========================<br> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-2921.txt</h3><br>=========================<br> <B>compilers</B> translators<br>****************************<br><br><br><h3>CACM-2685.txt</h3><br>=========================<br>the <B>parallel</B> execution of do loops methods are developed for the <B>parallel</B> execution of different iterations of a do loop both asynchronous multiprocessor computers and array computers are considered practical application to the design of <B>compilers</B> for such computers is discussed cacm february 1974 lamport l <B>parallel</B> computing multiprocessor computers array computers vector computers loops 4.12<br>****************************<br><br><br><h3>CACM-3066.txt</h3><br>=========================<br>a controlled experiment in program testing and <B>code</B> walkthroughsinspections this paper describes an experiment in program testing employing 59 <B>highly</B> experienced data processing professionals using seven methods to test a small pli program the results show that the popular <B>code</B> walk throughinspection method was as effective as other computer-based methods<br>****************************<br><br><br><h3>CACM-3066.txt</h3><br>=========================<br> <B>code</B> walkthroughs <B>code</B> inspections<br>****************************<br><br><br><h3>CACM-1923.txt</h3><br>=========================<br>pseudofiles an approach to system interfaces for high level <B>languages</B> using basic inputoutput support facilities is described it is shown that this technique can provide potentially inexpensive methods for programs to communicate with deeply embedded facilities such as command language <B>processors</B> cacm march 1969 rosin r f operating systems interfaces input-output high level <B>languages</B> command<br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br>automatic generation of efficient lexical <B>processors</B> using finite state techniques the practical application of the theory of finite-state automata to automatically generate lexical <B>processors</B> is dealt with in this tutorial article by the use of the aed rword<br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> is identified by a <B>code</B><br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> the <B>processors</B> produced<br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> <B>machines</B> each state<br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> and <B>processors</B> generated<br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> lexical <B>processors</B><br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> these <B>processors</B> may<br>****************************<br><br><br><h3>CACM-1665.txt</h3><br>=========================<br> <B>processors</B> which would<br>****************************<br><br><br><h3>CACM-2570.txt</h3><br>=========================<br>a comparison of list schedules for <B>parallel</B> processing systems the problem of scheduling two or more <B>processors</B> to minimize the execution time of a program which consists of a set of partially ordered tasks is studied cases where task execution times are deterministic and others in which execution times are random variables are analyzed it is shown that different algorithms<br>****************************<br><br><br><h3>CACM-2570.txt</h3><br>=========================<br> <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-2896.txt</h3><br>=========================<br>an exercise in proving <B>parallel</B> programs correct a <B>parallel</B> program dijkstras on-the-fly garbage collector is proved correct using a proof method developed by owicki the fine degree of in terleaving in this program makes it <B>especially</B> difficult to understand and complicates the proof greatly difficulties with proving such <B>parallel</B> programs correct are discussed cacm december 1977 gries d garbage<br>****************************<br><br><br><h3>CACM-3150.txt</h3><br>=========================<br> of a <B>machines</B> order <B>code</B><br>****************************<br><br><br><h3>CACM-3150.txt</h3><br>=========================<br>beyond programming <B>languages</B> as computer technology matures our growing ability to create large systems is leading to basic changes in the nature of programming current programming language concepts will not be adequate for building and maintaining systems of the complexity called for by the tasks we attempt just as high level <B>languages</B><br>****************************<br><br><br><h3>CACM-3150.txt</h3><br>=========================<br> <B>languages</B> as they now<br>****************************<br><br><br><h3>CACM-3150.txt</h3><br>=========================<br> <B>languages</B> programming<br>****************************<br><br><br><h3>CACM-2661.txt</h3><br>=========================<br>ideal teaching <B>machines</B>-a solution to the pedagogic language problem cacm april 1974 sterling t d pollack s v education programming <B>languages</B> simulators 1.52 4.2 ca740409 jb february 1 1978 10:38 am 2661 5 2661 2661 5 2661 2661 5 2661<br>****************************<br><br><br><h3>CACM-2706.txt</h3><br>=========================<br>a note on the set basis problem related to the <B>compaction</B> of character sets this note discusses the reduction of the set basis problem to the clique cover problem cacm november 1975 kou l t wong c k <B>compaction</B> of character sets set basis set covering computational complexity polynomial completeness clique cover 4.9 5.25 5.39 ca751106 jb january 6 1978 8:55 am 2706 4 2706 2643 5 2706 2706 5 2706<br>****************************<br><br><br><h3>CACM-1163.txt</h3><br>=========================<br>philcoibm translation at problem-oriented symbolic and binary levels a translation system has been developed to eliminate most of the effort formerly required to reprogram philco 2000 series codes for ibm 7094 operation experience with this system is limited but <B>highly</B> successful encouraging application of the techniques to other source and object <B>languages</B> cacm december 1965 olsen t m ca651206<br>****************************<br><br><br><h3>CACM-2785.txt</h3><br>=========================<br>glypnir-a programming language for illiac iv glypnir is one of the earliest existing <B>languages</B> designed for programming the illiac iv computer the syntax of the language is based on algol 60 but has been extended to allow the programmer explicitly to specify the parallelism of his algorithm in terms of 64-word vectors this paper<br>****************************<br><br><br><h3>CACM-2785.txt</h3><br>=========================<br> associated with <B>parallel</B><br>****************************<br><br><br><h3>CACM-2785.txt</h3><br>=========================<br> <B>parallel</B> computation <B>parallel</B> architecture<br>****************************<br><br><br><h3>CACM-1159.txt</h3><br>=========================<br>machine independence its technology and economics a survey is offered of techniques for transferring programs and <B>especially</B> <B>compilers</B> from one computer to another of the methods examined the bootstrap technique is singled out for detailed discussion with emphasis on its economics the considerations that determine the applicability of bootstrapping in any specific case are discussed<br>****************************<br><br><br><h3>CACM-0243.txt</h3><br>=========================<br> the <B>horizontal</B> the vertical<br>****************************<br><br><br><h3>CACM-0243.txt</h3><br>=========================<br>-dimensional <B>code</B> correcting<br>****************************<br><br><br><h3>CACM-3175.txt</h3><br>=========================<br> in <B>parallel</B> for all <B>code</B><br>****************************<br><br><br><h3>CACM-3175.txt</h3><br>=========================<br>breaking substitution ciphers using a relaxation algorithm substitution ciphers are codes in which each letter of the alphabet has one fixed substitute and the word divisions do not change in this paper the problem of breaking substitution ciphers is represented as a probabilistic labeling problem every <B>code</B> letter is assigned probabilities of representing plain text letters<br>****************************<br><br><br><h3>CACM-2423.txt</h3><br>=========================<br>a parser-generating system for constructing compressed <B>compilers</B> this paper describes a parser-generating system pgs currently in use on the cdc-6500 computer at purdue university the pgs is a fortran-coded compiler in the input translation grammar each bnf syntactic rule corresponds to a possibly empty <B>code</B> generator realizable as an assembly language<br>****************************<br><br><br><h3>CACM-2423.txt</h3><br>=========================<br>-pass <B>compilers</B><br>****************************<br><br><br><h3>CACM-2423.txt</h3><br>=========================<br> to <B>code</B> generators<br>****************************<br><br><br><h3>CACM-0637.txt</h3><br>=========================<br>a neliac-generated 7090-1401 compiler neliac systems for several different <B>machines</B> have been generated using the original neliac system developed at the naval electronics laboratory san diego in 1958 a basic bootstrap process was used to generate all but the first ie the systems were described in the neliac language and generated by an existing neliac compiler this experience<br>****************************<br><br><br><h3>CACM-0637.txt</h3><br>=========================<br> <B>compilers</B> with <B>compilers</B><br>****************************<br><br><br><h3>CACM-2497.txt</h3><br>=========================<br>synchronizing <B>processors</B> with memory-content-generated interrupts implementations of the lock-unlock method of synchronizing <B>processors</B> in a multiprocessor system usually require uninterruptable memory-pause type instructions an interlock scheme called read-interlock which does not require memory-pause instructions has been developed for a dual dec pdp-10<br>****************************<br><br><br><h3>CACM-2497.txt</h3><br>=========================<br> of the <B>processors</B> and a special<br>****************************<br><br><br><h3>CACM-2497.txt</h3><br>=========================<br> <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-2064.txt</h3><br>=========================<br>operations on generalized arrays with the genie compiler operations on vectors matrices and higher dimensional storage arrays are standard features of most <B>compilers</B> today the elements of such structures are usually restricted to be scalars for many sophisticated applications this restriction can impose cumbersome data representations an efficient system<br>****************************<br><br><br><h3>CACM-2064.txt</h3><br>=========================<br> <B>code</B> words may describe<br>****************************<br><br><br><h3>CACM-2064.txt</h3><br>=========================<br> <B>compilers</B> 4.12 4.29 ca700502<br>****************************<br><br><br><h3>CACM-2567.txt</h3><br>=========================<br>an exponential method for the solution of systems of ordinary differential equations an explicit coupled single-step method for the numerical solution of initial value problems for systems of ordinary differential equations is presented the method was designed to be general purpose in nature but to be <B>especially</B> efficient when dealing with stiff systems of differential<br>****************************<br><br><br><h3>CACM-2567.txt</h3><br>=========================<br> <B>highly</B> stiff systems<br>****************************<br><br><br><h3>CACM-2644.txt</h3><br>=========================<br>a theorem-proving language for experimentation because of the large number of strategies and inference rules presently under consideration in automated theorem proving there is a need for developing a language <B>especially</B> oriented toward automated theorem proving this paper discusses some of the features and instructions of this language the use of this language permits easy<br>****************************<br><br><br><h3>CACM-2644.txt</h3><br>=========================<br> <B>languages</B> 3.60 4.22<br>****************************<br><br><br><h3>CACM-2904.txt</h3><br>=========================<br> cocke j <B>compilers</B><br>****************************<br><br><br><h3>CACM-2904.txt</h3><br>=========================<br> of compiled <B>code</B> program<br>****************************<br><br><br><h3>CACM-1425.txt</h3><br>=========================<br>flow diagrams turing <B>machines</B> and <B>languages</B> with only two formation rules in the first part of the paper flow diagrams are introduced to represent inter al mappings of a set into itself although not every diagram is decomposable into a finite number of given base diagrams this becomes true at a semantical level due to a suitable<br>****************************<br><br><br><h3>CACM-1425.txt</h3><br>=========================<br> of turing <B>machines</B><br>****************************<br><br><br><h3>CACM-1425.txt</h3><br>=========================<br> from the two <B>machines</B><br>****************************<br><br><br><h3>CACM-1425.txt</h3><br>=========================<br> family of turing <B>machines</B><br>****************************<br><br><br><h3>CACM-2298.txt</h3><br>=========================<br>an environment for research in microprogramming and emulation the development of the research project in microprogramming and emulation at state university of new york at buffalo consisted of three phases the evaluation of various possible <B>machines</B> to support this research the decision to purchase one such machine which appears to be superior to the others considered<br>****************************<br><br><br><h3>CACM-2298.txt</h3><br>=========================<br> <B>processors</B> input-output<br>****************************<br><br><br><h3>CACM-2886.txt</h3><br>=========================<br>semantic evaluation from left to right this paper describes attribute grammars and their use for the definition of programming <B>languages</B> and <B>compilers</B> a formal definition of attribute grammars and a discussion of some of its important aspects are included the paper concentrates on the evaluation of semantic attributes in a few passes from left to right over<br>****************************<br><br><br><h3>CACM-2886.txt</h3><br>=========================<br> <B>languages</B> semantic<br>****************************<br><br><br><h3>CACM-2886.txt</h3><br>=========================<br> <B>compilers</B> semantic<br>****************************<br><br><br><h3>CACM-3005.txt</h3><br>=========================<br> a <B>highly</B> compact<br>****************************<br><br><br><h3>CACM-3005.txt</h3><br>=========================<br> a huffman <B>code</B> which<br>****************************<br><br><br><h3>CACM-3005.txt</h3><br>=========================<br> 1-byte op <B>code</B><br>****************************<br><br><br><h3>CACM-2433.txt</h3><br>=========================<br> rather than <B>code</B><br>****************************<br><br><br><h3>CACM-2433.txt</h3><br>=========================<br> <B>parallel</B> algorithms<br>****************************<br><br><br><h3>CACM-2433.txt</h3><br>=========================<br> <B>parallel</B> control<br>****************************<br><br><br><h3>CACM-0303.txt</h3><br>=========================<br>some basic terminology connected with mechanical <B>languages</B> and their <B>processors</B> the suggestions in this paper are part of the terminology used in work for the university of pennsylvanias office of computer research and education the work is jointly supported by the national science foundation and the air force office of scientific research cacm august 1961 gorn s ca610801 jb march 16 1978 10:16<br>****************************<br><br><br><h3>CACM-3127.txt</h3><br>=========================<br>thoth a portable real-time operating system thoth isa real-time operating system which is designed to be portable over a large set of <B>machines</B> it is currently running on two minicomputers with quite different architectures both the system and application programs which use it are written in a high-level language because the system is implemented by the same software<br>****************************<br><br><br><h3>CACM-3127.txt</h3><br>=========================<br> are <B>highly</B> portable<br>****************************<br><br><br><h3>CACM-1099.txt</h3><br>=========================<br> be <B>especially</B> suited<br>****************************<br><br><br><h3>CACM-1099.txt</h3><br>=========================<br> <B>machines</B><br>****************************<br><br><br><h3>CACM-3171.txt</h3><br>=========================<br>line numbers made cheap a technique is described for run-time line number administration to be used for implementations of high level <B>languages</B> under suitable circumstances this method requires absolutely no overhead in either time or space during execution of the program cacm october 1979 klint p line number administration diagnostic messages abstract machine <B>code</B> 4.12 4.13 4.20 4.42 ca791004 db<br>****************************<br><br><br><h3>CACM-3080.txt</h3><br>=========================<br>proving the correctness of heuristically optimized <B>code</B> a system for proving that programs written in a high level language are correctly translated to a low level language is described a primary use of the system is as a post optimization step in <B>code</B> generation the low level language programs need not be generated by a compiler and in fact could be hand<br>****************************<br><br><br><h3>CACM-3080.txt</h3><br>=========================<br> <B>compilers</B> correctness <B>code</B> optimization<br>****************************<br><br><br><h3>CACM-2289.txt</h3><br>=========================<br> for <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-2289.txt</h3><br>=========================<br> for parallelism <B>especially</B><br>****************************<br><br><br><h3>CACM-2289.txt</h3><br>=========================<br> <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-1154.txt</h3><br>=========================<br>multi-tape and infinite-state automata -- a survey a survey of <B>machines</B> which are more powerful than finite automata and less powerful than general turing <B>machines</B> is presented it is felt that the <B>machines</B> in this category are as closely related to digital computers as either the finite automata or the unrestricted turing <B>machines</B> intermediate <B>machines</B> can be created by adjoining on infinite<br>****************************<br><br><br><h3>CACM-2514.txt</h3><br>=========================<br>an array grammar programming system a package of fortran programs has been developed that permits a user to interactively design and test array grammars the user can control the rule selection procedure in a derivation or parse using weighted programming matrices he also has a choice of instance selection schemes rasterrandom <B>parallel</B> examples are given involving array <B>languages</B> consisting<br>****************************<br><br><br><h3>CACM-3148.txt</h3><br>=========================<br>high level programming for distributed computing programming for distributed and other loosely coupled systems is a problem of growing interest this paper describes an approach to distributed computing at the level of general purpose programming <B>languages</B> based on primitive notions of module message and transaction key the methodology<br>****************************<br><br><br><h3>CACM-3148.txt</h3><br>=========================<br> <B>languages</B> and <B>machines</B> it appears<br>****************************<br><br><br><h3>CACM-3148.txt</h3><br>=========================<br> <B>languages</B><br>****************************<br><br><br><h3>CACM-2411.txt</h3><br>=========================<br>tree-structured programs cacm november 1973 wegner e control structures flowcharts goto statements inductive assertion least fix points optimization in <B>compilers</B> program documentation program flow graphs programming language design proof of programs semantics of programming <B>languages</B> structured programming 4.12 4.22 5.24 ca731115 jb january 19 1978 4:19 pm 2411 4 2411 2411 4 2411 2457 4 2411 2709<br>****************************<br><br><br><h3>CACM-2717.txt</h3><br>=========================<br>convert a high level translation definition language for data conversion this paper describes a high level and nonprocedural translation definition language convert which provides very powerful and <B>highly</B> flexible data restructuring capabilities its design is based on the simple underlying concept of a form which enables the users to visualize<br>****************************<br><br><br><h3>CACM-2717.txt</h3><br>=========================<br> programming <B>languages</B> nonprocedural <B>languages</B><br>****************************<br><br><br><h3>CACM-1738.txt</h3><br>=========================<br> flexible and <B>highly</B><br>****************************<br><br><br><h3>CACM-1738.txt</h3><br>=========================<br> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-0082.txt</h3><br>=========================<br>handling identifiers as internal symbols in language <B>processors</B> substitution of computer-oriented symbols for programmer-oriented symbols in language <B>processors</B> is examined and a feasible method for doing so is presented cacm june 1959 williams f a ca590602 jb march 22 1978 6:38 pm 222 5 82 82 5 82 82 5 82 82 5 82 799 5 82 945 6 82 399 6 82 44 6 82 82 6 82 82 6 82 404 6 82<br>****************************<br><br><br><h3>CACM-2253.txt</h3><br>=========================<br>index ranges for matrix calculi the paper describes a scheme for symbolic manipulation of index expressions which arise as a by-product of the symbolic manipulation of expressions in the matrix calculi described by the authors in a previous paper this scheme attempts program optimization by transforming the original algorithm rather than the machine <B>code</B><br>****************************<br><br><br><h3>CACM-2253.txt</h3><br>=========================<br> is to automatically generate <B>code</B><br>****************************<br><br><br><h3>CACM-2253.txt</h3><br>=========================<br> <B>languages</B> program<br>****************************<br><br><br><h3>CACM-1409.txt</h3><br>=========================<br> <B>parallel</B> <B>machines</B><br>****************************<br><br><br><h3>CACM-1603.txt</h3><br>=========================<br>a multiprogramming monitor for small <B>machines</B> int a combination hardwaresoftware monitor designed to control a wide variety of real-time inputoutput devices is described the simple hardware additions provide a uniform device to machine interface for such elements as keyboards graphic input devices and interval timers the software relieves the user program from the details<br>****************************<br><br><br><h3>CACM-1603.txt</h3><br>=========================<br> <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-2645.txt</h3><br>=========================<br>two <B>languages</B> for estimating program efficiency two <B>languages</B> enabling their users to estimate the efficiency of computer programs are presented the program whose efficiency one wishes to estimate is written in the first language a go-to-less programming language which includes most of the features of algol 60<br>****************************<br><br><br><h3>CACM-2645.txt</h3><br>=========================<br> <B>processors</B> for the two <B>languages</B> are also<br>****************************<br><br><br><h3>CACM-2645.txt</h3><br>=========================<br> of the two <B>languages</B><br>****************************<br><br><br><h3>CACM-2645.txt</h3><br>=========================<br> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-1807.txt</h3><br>=========================<br> fortran <B>compilers</B><br>****************************<br><br><br><h3>CACM-1807.txt</h3><br>=========================<br> <B>code</B> without<br>****************************<br><br><br><h3>CACM-1807.txt</h3><br>=========================<br> expressions <B>compilers</B><br>****************************<br><br><br><h3>CACM-2929.txt</h3><br>=========================<br> <B>code</B> and a small<br>****************************<br><br><br><h3>CACM-2929.txt</h3><br>=========================<br> optimization <B>compilers</B><br>****************************<br><br><br><h3>CACM-2929.txt</h3><br>=========================<br> <B>languages</B> run-time<br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br><B>code</B> extension in ascii an asa tutorial the american standard <B>code</B> for information interchange ascii contains a number of control characters associated with the principle of <B>code</B> extension that is with the representation of information which cannot<br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> in the <B>code</B><br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> regarding <B>code</B><br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> of the <B>code</B> extension<br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> between <B>code</B> extension<br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> concerned with <B>code</B><br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> on <B>code</B> applications<br>****************************<br><br><br><h3>CACM-1362.txt</h3><br>=========================<br> <B>code</B> for information<br>****************************<br><br><br><h3>CACM-1591.txt</h3><br>=========================<br> <B>processors</B> <B>compilers</B><br>****************************<br><br><br><h3>CACM-1680.txt</h3><br>=========================<br> <B>processors</B> and <B>compilers</B><br>****************************<br><br><br><h3>CACM-1262.txt</h3><br>=========================<br>procedure-oriented language statements to facilitate <B>parallel</B> processing two statements are suggested which allow a programmer writing in a procedure-oriented language to indicate sections of program which are to be executed in <B>parallel</B> the statements are do together and hold these serve partly as brackets in establishing a range of <B>parallel</B> operation and partly to define each <B>parallel</B> path<br>****************************<br><br><br><h3>CACM-2700.txt</h3><br>=========================<br>reduction a method of proving properties of <B>parallel</B> programs when proving that a <B>parallel</B> program has a given property it is often convenient to assume that a statement is indivisible ie that the statement cannot be interleaved with the rest of the program here sufficient conditions are obtained to show that the assumption that a statement is indivisible<br>****************************<br><br><br><h3>CACM-2700.txt</h3><br>=========================<br> proofs of a <B>parallel</B><br>****************************<br><br><br><h3>CACM-2700.txt</h3><br>=========================<br> <B>parallel</B> program<br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br>shift-register <B>code</B> for indexing applications in this communication the use of a shift-register <B>code</B> with n  10 is described for calling 64 wireless telemetering stations in a fixed cyclical order a high degree of redundancy is used<br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br> correcting <B>code</B><br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br> <B>code</B> with 64 10-bit <B>code</B> words<br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br> identification <B>code</B><br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br> <B>code</B> with period 1023 permits the <B>code</B><br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br> time the given <B>code</B><br>****************************<br><br><br><h3>CACM-0048.txt</h3><br>=========================<br> of the <B>code</B> in some<br>****************************<br><br><br><h3>CACM-1747.txt</h3><br>=========================<br> of <B>parallel</B> processes<br>****************************<br><br><br><h3>CACM-1747.txt</h3><br>=========================<br> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-1747.txt</h3><br>=========================<br> <B>parallel</B> processing <B>parallel</B> programming<br>****************************<br><br><br><h3>CACM-3074.txt</h3><br>=========================<br>a time- and space- efficient garbage <B>compaction</B> algorithm given an area of storage containing scattered marked nodes of differing sizes one may wish to rearrange them into a compact mass at one end of the area while revising all pointers to marked nodes to show their new locations an algorithm is described here which accomplishes this task in linear time relative to the size<br>****************************<br><br><br><h3>CACM-3074.txt</h3><br>=========================<br> <B>compaction</B> compact<br>****************************<br><br><br><h3>CACM-2491.txt</h3><br>=========================<br>threaded <B>code</B> the concept of threaded <B>code</B> is presented as an alternative to machine language <B>code</B> hardware and software realizations of it are given in software it is realized as interpretive <B>code</B> not needing an interpreter extensions and optimizations are mentioned cacm june 1973 bell j r interpreter machine <B>code</B> time tradeoff space tradeoff compiled <B>code</B> subroutine calls threaded <B>code</B> 4.12<br>****************************<br><br><br><h3>CACM-2973.txt</h3><br>=========================<br>sorting on a mesh-connected <B>parallel</B> computer two algorithms are presented for sorting n2 elements on an n x n mesh-connected processor array that require on routing and comparison steps the best previous algorithm takes time on log n the algorithms of this paper are shown to be optimal in time within small constant factors extensions<br>****************************<br><br><br><h3>CACM-2973.txt</h3><br>=========================<br> <B>parallel</B> computer <B>parallel</B> sorting <B>parallel</B> merge routing<br>****************************<br><br><br><h3>CACM-2748.txt</h3><br>=========================<br>indirect threaded <B>code</B> an efficient arrangement for interpretive <B>code</B> is described it is related to bells notion of threaded <B>code</B> but requires less space and is more amenable to machine independent implementations cacm june 1975 dewar r b k threaded <B>code</B> snobol4 interpretors <B>code</B> generation 4.12 4.13 ca750605 jb january 9 1978 1:11 pm 2748 4 2748 3144 4 2748 2491 5 2748 2748 5 2748 2748 5 2748 2748 5 2748<br>****************************<br><br><br><h3>CACM-1135.txt</h3><br>=========================<br>-speed <B>compilers</B><br>****************************<br><br><br><h3>CACM-1135.txt</h3><br>=========================<br> in the <B>languages</B> as opposed<br>****************************<br><br><br><h3>CACM-1135.txt</h3><br>=========================<br> <B>languages</B> and fully<br>****************************<br><br><br><h3>CACM-1135.txt</h3><br>=========================<br> for such <B>languages</B><br>****************************<br><br><br><h3>CACM-1655.txt</h3><br>=========================<br><B>code</B> extension procedures for information interchange proposed usa standard cacm december 1968 standard <B>code</B> <B>code</B> information interchange characters shift out shift in escape data link escape control functions standard procedures <B>code</B> extension <B>code</B> table bit pattern 1.0 2.0 2.43 3.20 3.24 3.50 3.51 3.52 3.53 3.54 3.55 3.56 3.57 3.70 3.71 3.72 3.73 3.74 3.75 3.80 3.81 3.82 3.83 5.0 5.1 6.2 6.21<br>****************************<br><br><br><h3>CACM-1947.txt</h3><br>=========================<br>object <B>code</B> optimization methods of analyzing the control flow and data flow of programs during compilation are applied to transforming the program to improve object time efficiency dominance relationships indicating which statements are necessarily executed before others are used to do global common expression elimination and loop identification<br>****************************<br><br><br><h3>CACM-1947.txt</h3><br>=========================<br> medlock c w <B>compilers</B><br>****************************<br><br><br><h3>CACM-1947.txt</h3><br>=========================<br> object <B>code</B><br>****************************<br><br><br><h3>CACM-1389.txt</h3><br>=========================<br>a programmers description of l6 bell telephone laboratories low-linked list language l6 pronounced l-six is a new programming language for list structure manipulations it contains many of the facilities which underlie such list <B>processors</B> as ipl lisp comit ad snobol but permits the user to get much closer to machine <B>code</B> in order to write faster-running programs to use storage more efficiently<br>****************************<br><br><br><h3>CACM-2989.txt</h3><br>=========================<br>empirical evaluation of some features of instruction set processor architectures this paper presents methods for empirical evaluation of features of instruction set <B>processors</B> isps isp features are evaluated in terms of the time used or saved by having or not having the feature the methods are based on analysis of traces of program executions the concept of a register life<br>****************************<br><br><br><h3>CACM-2989.txt</h3><br>=========================<br> <B>code</B> utilization<br>****************************<br><br><br><h3>CACM-2633.txt</h3><br>=========================<br> <B>compaction</B> 4.41 5.13<br>****************************<br><br><br><h3>CACM-1652.txt</h3><br>=========================<br>a <B>code</B> for non-numeric information processing applications in online systems a <B>code</B> has been specifically designed to simplify the internal information processing operations within an online computer system with respect to non-numeric applications and to maximize the transfer rate<br>****************************<br><br><br><h3>CACM-1652.txt</h3><br>=========================<br> and the system user the <B>code</B><br>****************************<br><br><br><h3>CACM-1652.txt</h3><br>=========================<br> this <B>code</B> called ipc<br>****************************<br><br><br><h3>CACM-1652.txt</h3><br>=========================<br> <B>code</B> is an 8-bit <B>code</B> set constructed so<br>****************************<br><br><br><h3>CACM-1652.txt</h3><br>=========================<br> the basic set the <B>code</B><br>****************************<br><br><br><h3>CACM-2579.txt</h3><br>=========================<br> allocation <B>compilers</B> programming <B>languages</B><br>****************************<br><br><br><h3>CACM-2231.txt</h3><br>=========================<br>the reconstruction of binary patterns from their projections given the <B>horizontal</B> and vertical projections of a finite binary pattern f can we construct the original pattern f in this paper we give a characterization of patterns that are reconstructable from their projection three algorithms are developed to reconstruct both unambiguous and ambiguous patterns it is shown that an unambiguous<br>****************************<br><br><br><h3>CACM-2820.txt</h3><br>=========================<br>the design and implementation of a table driven interactive diagnostic programming system caps is a <B>highly</B> interactive diagnostic compilerinterpreter that allows beginning programmers to prepare debug and execute fairly simple programs at a graphics display terminal complete syntax checking and most semantic analysis is performed as the program is entered and as it is subsequently<br>****************************<br><br><br><h3>CACM-2820.txt</h3><br>=========================<br> <B>compilers</B> error<br>****************************<br><br><br><h3>CACM-1385.txt</h3><br>=========================<br> <B>machines</B> in 1958-59<br>****************************<br><br><br><h3>CACM-1385.txt</h3><br>=========================<br>-made <B>machines</B> from<br>****************************<br><br><br><h3>CACM-1385.txt</h3><br>=========================<br> <B>machines</B> probably being<br>****************************<br><br><br><h3>CACM-1158.txt</h3><br>=========================<br>program structures for <B>parallel</B> processing constructs for organizing and explicating <B>parallel</B> program segments are discussed as extensions to algol 60 the constructs serve as meta-commands and are motivated by equipment having multiprocessing capability cacm december 1965 anderson j p ca651211 jb march 6 1978 3:39 pm 1158 4 1158 1158 5 1158 1158 5 1158 1158 5 1158 1262 5 1158<br>****************************<br><br><br><h3>CACM-2939.txt</h3><br>=========================<br>abstraction mechanisms in clu clu is a new programming language designed to support the use of abstractions in program construction work in programming methodology has led to the realization that three kinds of abstractions-procedural control and <B>especially</B> data abstractions-are useful in the programming process of these only the procedural abstraction<br>****************************<br><br><br><h3>CACM-2939.txt</h3><br>=========================<br> by conventional <B>languages</B><br>****************************<br><br><br><h3>CACM-2939.txt</h3><br>=========================<br> <B>languages</B> data types<br>****************************<br><br><br><h3>CACM-2034.txt</h3><br>=========================<br> 15 <B>machines</B> of widely<br>****************************<br><br><br><h3>CACM-2034.txt</h3><br>=========================<br> <B>languages</B> implementation<br>****************************<br><br><br><h3>CACM-2819.txt</h3><br>=========================<br> file <B>compaction</B><br>****************************<br><br><br><h3>CACM-1844.txt</h3><br>=========================<br> of the <B>machines</B> used<br>****************************<br><br><br><h3>CACM-1844.txt</h3><br>=========================<br> the potential of a <B>highly</B><br>****************************<br><br><br><h3>CACM-1756.txt</h3><br>=========================<br>hollerith punched card <B>code</B> proposed usa standard cacm april 1968 usa standard card <B>code</B> punched card punched card <B>code</B> hole-patterns hole-patterns assignment punched card systems 1.4 2.0 2.2 2.43 2.9 3.15 3.24 3.50 3.57 3.7 3.80 3.81 3.82 4.11 4.12 ca680414 jb february 23 1978 10:14 am 1756 5 1756 1756 5 1756 1756 5 1756<br>****************************<br><br><br><h3>CACM-0719.txt</h3><br>=========================<br> of <B>machines</B> of this class<br>****************************<br><br><br><h3>CACM-0719.txt</h3><br>=========================<br> <B>machines</B> with fixed<br>****************************<br><br><br><h3>CACM-2692.txt</h3><br>=========================<br> <B>code</B> capable<br>****************************<br><br><br><h3>CACM-2692.txt</h3><br>=========================<br> <B>code</B> is reentered<br>****************************<br><br><br><h3>CACM-2692.txt</h3><br>=========================<br> <B>parallel</B><br>****************************<br><br><br><h3>CACM-1463.txt</h3><br>=========================<br>more on extensible <B>machines</B> one of the most salient characteristics of extensible <B>machines</B> em is the facility for providing system control over program-to-program and program-to-data linkage eg address connection it is the intent of this paper to expand and clarify the remarks concerning program-to-program and program-to-data linkage that were embodied in the authors previous<br>****************************<br><br><br><h3>CACM-1463.txt</h3><br>=========================<br> <B>languages</B> cacm<br>****************************<br><br><br><h3>CACM-2401.txt</h3><br>=========================<br>on shrinking binary picture patterns a <B>parallel</B> processing algorithm for shrinking binary patterns to obtain single isolated elements one for each pattern is presented this procedure may be used for counting patterns on a matrix and a hardware implementation of the algorithm using large scale integrated technology is envisioned the principal features<br>****************************<br><br><br><h3>CACM-2401.txt</h3><br>=========================<br> elements the <B>parallel</B><br>****************************<br><br><br><h3>CACM-2401.txt</h3><br>=========================<br> <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-3059.txt</h3><br>=========================<br>models for <B>parallel</B> processing within programs application to cpuio and ioio overlap approximate queueing models for internal <B>parallel</B> processing by individual programs in a multiprogrammed system are developed in this paper the solution technique is developed by network decomposition the models are formulated in terms of cpuio and ioio overlap and applied to the analysis<br>****************************<br><br><br><h3>CACM-3059.txt</h3><br>=========================<br> <B>parallel</B> processing<br>****************************<br><br><br><h3>CACM-2740.txt</h3><br>=========================<br>a large semaphore based operating system the paper describes the internal structure of a large operating system as a set of cooperating sequential processes the processes synchronize by means of semaphores and extended semaphores queue semaphores the number of <B>parallel</B> processes is carefully justified and the various semaphore constructions are explained<br>****************************<br><br><br><h3>CACM-2740.txt</h3><br>=========================<br> buffering <B>parallel</B><br>****************************<br><br><br><h3>CACM-2740.txt</h3><br>=========================<br> <B>code</B> rc 4000 project<br>****************************<br><br><br><h3>CACM-3048.txt</h3><br>=========================<br>performance evaluation of <B>highly</B> concurrent computers by deterministic simulation simulation is presented as a practical technique for performance evaluation of alternative configurations of <B>highly</B> concurrent computers a technique is described for constructing a detailed deterministic simulation model of a system in the model a control stream replaces the instruction and data streams of the real<br>****************************<br><br><br><h3>CACM-1828.txt</h3><br>=========================<br>synchronization in a <B>parallel</B>-accessed data base the following problem is considered given a data base which can be manipulated simultaneously by more than one process what are the rules for synchronization which will maximize the amount of <B>parallel</B> activity allowed it is assumed that the data base can be represented as a graph an example of such a data<br>****************************<br><br><br><h3>CACM-1828.txt</h3><br>=========================<br> <B>parallel</B> accessing <B>parallel</B> search file<br>****************************<br><br><br><h3>CACM-1310.txt</h3><br>=========================<br>a rapid braille transliteration technique for certain ibm <B>machines</B> cacm february 1965 weiler w j klema v c ca650214 jb march 7 1978 10:55 pm 1310 5 1310 1310 5 1310 1310 5 1310<br>****************************<br><br><br><h3>CACM-2316.txt</h3><br>=========================<br>programming <B>languages</B> history and future this paper discusses both the history and future of programming <B>languages</B>  higher level <B>languages</B> some of the difficulties in writing such a history are indicated a key part of the paper is a tree showing the chronological development of <B>languages</B><br>****************************<br><br><br><h3>CACM-2316.txt</h3><br>=========================<br> of <B>languages</B> are given the major <B>languages</B><br>****************************<br><br><br><h3>CACM-2316.txt</h3><br>=========================<br> <B>languages</B> are discussed<br>****************************<br><br><br><h3>CACM-2316.txt</h3><br>=========================<br> <B>languages</B> higher level <B>languages</B> <B>languages</B><br>****************************<br><br><br>